# R2: Key Management

To ensure that communication between devices and the platform is secure, a two-layer key management system has been implemented. There are two types of keys: a **Master Key** (Authentication Key) and a **Session Key** (Encryption Key). The Master Key is derived from the device PIN and is used only to authenticate key rotation requests. The Session Key is used to encrypt sensor data and is rotated automatically over time or after a number of messages.

---

## Key types

| Key | Derivation | Purpose |
|-----|-----------|---------|
| **Master Key** | PBKDF2-SHA256 from PIN (100,000 iterations, 256-bit) | Authenticates key rotation requests. Never used to encrypt sensor data. |
| **Session Key** | Random 256-bit key generated by the platform | Encrypts all sensor data (AES-GCM or AES-CBC+HMAC). Rotated periodically. |

---

## Key Manager (`key_manager.py`)

All key logic is centralised in the `KeyManager` class. Each device and the platform share one `KeyManager` instance per device, identified by `device_id`.

Key operations:

- `derive_master_key(pin)` — derives the Master Key from the PIN.
- `set_session_key(key, key_id)` — stores a new Session Key and resets rotation counters.
- `get_session_key()` — returns the current Session Key and increments the message counter.
- `check_rotation_needed()` — returns `True` if rotation should be triggered.
- `save_keys()` / `load_keys()` — persists key state to `.keys/<device_id>.keys` (JSON format).

---

## Key rotation

Rotation is triggered automatically when either condition is met:

| Condition | Default | Environment variable |
|-----------|---------|----------------------|
| Time elapsed since last rotation | 60 seconds | `KEY_ROTATION_INTERVAL_SEC` |
| Number of messages sent | 100 messages | `KEY_ROTATION_MSG_LIMIT` |

### Rotation flow

1. Device calls `key_mgr.check_rotation_needed()` before each publish.
2. If `True`, the device sends a signed request to `iot/rekey`:

```json
{
    "device_id": "sensor1",
    "ts": "1708505000",
    "sig": "<HMAC-SHA256 of sorted payload, signed with Master Key, base64-encoded>"
}
```

3. Platform verifies the HMAC signature using the device's stored Master Key.
4. Platform generates a new random 32-byte Session Key and encrypts it with the device's Master Key (AES-GCM):

```json
{
    "device_id": "sensor1",
    "key_id": 2,
    "nonce": "<base64>",
    "ciphertext": "<base64>",
    "tag": "<base64>"
}
```

5. Device receives the response on `iot/rekey/response`, decrypts the new Session Key using its Master Key, and calls `key_mgr.set_session_key(new_key, key_id)`.

> **Note**: In a real deployment, the Session Key exchange would use an asymmetric mechanism (e.g. Diffie-Hellman). This implementation simulates that step using AES-GCM encryption over MQTT.

---

## New MQTT topics

Two new topics have been added alongside the existing ones from R1:

| Topic | Publisher | Subscriber | Purpose |
|-------|-----------|------------|---------|
| `iot/rekey` | Device | Platform | Key rotation request (HMAC-signed) |
| `iot/rekey/response` | Platform | Device | New Session Key (encrypted with Master Key) |

---

## Key storage

Keys are persisted to `.keys/<device_id>.keys` so the device can resume after a restart without requesting a new Session Key immediately. The file is JSON and contains:

```json
{
    "master_key": "<hex>",
    "session_key": "<hex>",
    "session_key_id": 1,
    "last_rotation_ts": 1708505000.0,
    "msg_count": 42
}
```

> **Security note**: In a real system, this file would be encrypted (e.g. using a hardware security module or OS keychain). Here it is stored in plaintext for simulation purposes only.

---

## Session key usage by algorithm

The Session Key is always 32 bytes (256-bit). Its usage differs depending on the chosen algorithm (see [R5_DATA_ENCRYPTION.md](R5_DATA_ENCRYPTION.md)):

| Algorithm | Key usage |
|-----------|-----------|
| `AES-GCM` | Full 32-byte key (AES-256-GCM) |
| `AES-CBC` | Split: first 16 bytes → `session_key` (encryption), last 16 bytes → `auth_key` (HMAC-SHA256) |

---

## How to run with accelerated rotation (for testing)

Set the environment variables before launching the platform and device:

```powershell
# Windows PowerShell
$env:KEY_ROTATION_INTERVAL_SEC = '10'
$env:KEY_ROTATION_MSG_LIMIT = '5'
```

```bash
# Linux / macOS
export KEY_ROTATION_INTERVAL_SEC=10
export KEY_ROTATION_MSG_LIMIT=5
```

With these values, rotation will trigger every 10 seconds or every 5 messages, making it easy to observe in the terminal output.
